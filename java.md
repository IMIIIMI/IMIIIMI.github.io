# 修饰符
## 访问级别

| 修饰符    | 同类 | 同包 | 子类 | 任何地方 |
| --------- | ---- | ---- | ---- |:-------- |
| public    | Y    | Y    | Y    | Y        |
| protected | Y    | Y    | Y    |          |
| default   | Y    | Y    |      |          |
| private   | Y    |      |      |          |
## 访问规则
只有默认的和public可以修饰类
成员方法的访问规则和属性一样

---
# 面向对象三大特征
## 绑定机制
静态绑定使用类型信息进行绑定，而动态绑定使用对象来解析绑定
### 动态绑定
编译器在编译时并不能确定要调用哪个方法
1. 调用对象方法时,改方法和该对象的内存地址/远行类型绑定
2. 调用对象属性时,没有对象绑定机制,哪里声明,哪里使用
### 静态绑定
1. 所有静态，私有和最终方法的绑定都在编译时完成
	1. static 是类的方法，而 final 和 private 方法是不能被子类重写的。因此在编译器就知道调用这些方法的对象所指向的类是哪个。
## 封装
1. 属性私有化
2. 提供公共的(public)的方法用于对属性的增删改查
3. set...get...
## 继承(extends)
![[Pasted image 20230718182455.png|400]]
### 方法调用顺序
1. 先本类,没有则父类(如果有,并且可以调用,则调用),如果有,则继续寻找父类的父类,直到objet类 
2. 如果多个基类中都有同名的方法,使用super遵循就近原则
### 语法 
```java
class 子类 extends 父类{
	构造器(){
		super();//默认隐藏
	}
	
}
```
1. 子类自动拥有父类的属性和方法
2. 子类必需调用父类的构造器 
3. 创建子类时默认调用父类的无参构造器,如果父类没有供无参构造器,则必须在子类的构造器中用super去指定使用父类的某个构造器完成对父类的初始化
4. super()只能在构造器中使用且必需放在构造器的第一行
5. this()和super()都只能放在构造器的第一行所以两个方法不能共存在一个构造器
6. 子类最多继承一个父类
### super
1. 访问父类的属性,除了private(私有)属性 super.属性名
2. 方法同上 super.方法名(参数) 
### 覆盖
  子类有一个方法和父类的某个方法的名称返回类型参数一样
1. 子类的参数方法名称要和父类完全一致
2. 子类的返回类型和父类的返回类型一样或者是父类返回类型的子类 例
```java
public Object a(){

}
public String a(){

}
```
3. 子类不能缩小父类的权限例如:父类的修饰符为public,子类的修饰符不能为权限更低的修饰符 
![[Pasted image 20230718191914.png|300]]
## 多态
1. 一个对象的编译类型和运行类型可以不一致
2. 编译类型在定义对象时,就确定了`Animal animal=new Dog()`(编译对象是Animal运行对象是Dog)
3. 运行类型是可以改变的`animal=new Car()`
### 向上转型
1. 本质:父类引用了子类的对象
2. 语法:`父类类型 引用名=new 子类类型()`
3. 特点:编译类型在左边,运行类型在右边 能调用的方法由编译类型(父类)决定 远行效果由运行类型(子类)决定
4. 调用方法时从子类开始查找
### 向下转型
为了调用子类的特有方法
1. 语法:`子类类型 引用名=(子类类型) 父类引用`
2. 只能强转父类的引用,不能强转父类的对象(理解:你一开始可以把猫叫做动物,也可以改变你的叫法叫猫,但是你不能把它叫做动物的其他子类(例如:狗))
3. 父类的引用必需指向得是当前目标类型的对象(向上转型过得对象)
4. 向下转型后,可以调用子类类型中所有的对象
### 属性的多态
1. 只看编译类型
2. #运算符 `instanceOf` 判断对象的类型是否为xx类型或xx类型的子类 `bb instanceOf AA`
### 数组的多态
1. 数组的定义类行为父类类型,里面实际保存的实际元素为子类类型:![[Pasted image 20230720161109.png]]
### 参数的多态 [[实例|实例]]
1. 方法定义的形参为父类类型,实参类型为子类类型

---
# Object类
#运算符 ==
1. 既可以判断基本类型又可以判断引用类型
2. 如果判断的是基本类型,判断的是值是否相等
3. 如果判断的是引用类型,判断的是地址是否相等 编译类型不影响
#方法
`clone()`:创建并返回此对象的一个副本
`equals()`:指示其他某个对象是否与此对象相等
1. 只能判断引用类型
2. 默认判断地址是否相同,子类中往往重写该方法,用于判断内容是否相同
`finalize()`:当回收垃圾器确定不存在对该对象的更多引用时,由对象的垃圾回收器调用此方法
1. 当对象被回收时,系统自动调用该对象的`finalize`方法释放资源,子类可以重写该方法
2. `duixiang==null`时该对象就是一个垃圾,垃圾回收器就会回收(销毁)对象,在销毁对象前,会调用该对象的`finalize()`方法,程序也就可以在`finalize()`中写自己的业务逻辑代码(比如释放资源:数据库连接,或者打开文件)
3. `finalize()`在obj类中默认什么都不做,即默认处理
4. `System.gc()`主动调用销毁
`getClass()`:返回此object的运行时类
`hashCode()`:返回该对象的哈希码值
1. 提高具有哈希结构的容器的效率
2. 两个引用如果指向的是同一个对象则哈希值肯定一样
3. 两个引用如果指向的是不同对象则哈希值不一样
4. 哈希值主要根据地址号,不能完全将哈希值等价于地址
5. 
`notify()`:唤醒在此对象监视器上等待的单个线程
`notifyAll`:唤醒在此对象监视器上等待的多个线程
`toString()`:返回该对象的字符串表示
1. 默认返回全类名+@+哈希值的十六进制 子类往往重写
2. 输出一个对象时`toString()`会被默认调用 例:`sout(duixiang)==sout(duixiang.toString())`
`wait()`:其他线程
---
# 断点调试
![[Pasted image 20230723085205.png]]
![[Pasted image 20230723085243.png]]
1. 在断点调试过程中,是运行状态,以对象的运行类型来执行
2. 
---
# 静态
`类名 对象名=new 类名();`
1. [[java#类加载|类加载]]
2. [[java#创建对象时的调用顺序|创建对象]]
3. [[java#构造器|调用构造器]]
## 类加载
1. 创建对象时
2. 创建子类对象实例时,父类也会被加载
3. 使用类的静态成员时,同时加载父类
## 静态成员
### 静态变量(类变量)
1. static修饰
2. 被类所有的对象实例共享
### 静态方法(类方法)
1. 静态方法没有this参数
2. 静态方法可以通过类名调用
3. 静态方法中不允许使用和对象有关的关键字(super this)参数, 重名用类名.成员
5. 静态方法只能访问静态成员
6. 非静态方法可以访问静态成员和普通成员
---
## 代码块(静态代码块/非静态代码块)
静态代码块**只能**访问静态成员,非静态代码块都可以访问
类似于方法没有返回值没有参数只有方法体,不通过对象或类显式调用,而是加载类或创建对象时隐式调用
```java
[修饰符]{
	代码
};
```
1. 修饰符只有默认和static
2. 分为静态代码块和非静态代码块,静态代码块随着类的加载而执行并且只会执行一次,非静态代码块每创建一个对象就执行一次
3. 逻辑语句可以为任何逻辑语句
4. ;号可以省略
---
## 创建对象时的调用顺序
一.创建对象时类中的**调用顺序**
1. 调用静态代码块和静态属性初始化(优先级一样,先定义先使用)
2. 调用非静态代码块和非静态属性的初始化(优先级同上)
3. 最后调用构造器
二.创建子类对象时的**调用顺序**
1. 父类的静态代码块和属性
2. 子类的静态代码块和属性
3. 父类的飞静态代码块和属性
4. 父类的构造器
5. 子类的飞静态代码块和属性
6. 子类的构造器
---
## 构造器
```java
修饰符 类名{
	super();
	调用非静态代码块;
	代码;
}
```

# 设计模式
## 单例模式
1. 采取一定的方法保证在整个的软件系统中对某个类只能有一个对象实例,并且该类只提供一个取得该对象实例的方法
2. 两种方式
	+ 饿汉式
		1. 构造器私有化
		2. 类的内部创建静态对象
		3. 向外部公开一个静态的方法
		4. ![[Pasted image 20230727085502.png|200]]
	+ 懒汉式
		1. 构造器私有化
		2. 声明一个静态对象但不创建对象
		3. 提供一个公开的方法判断是否创建过对象来返回对象 

# final
>不希望类被继承 不希望父类的某个方法被子类重写 不希望累得某个属性被修改 不希望局部变量被修改
1. final修饰的属性又叫常量
2. final在初始化时必须赋初值,如果没有则在构造器和代码块中赋初值,以为创建对象时会调用构造器所以可以
3. 如果final修饰的属性是静态的,则初始化的位置只能是①定义时②静态代码块,不能在构造器中
4. final类可以实例化,但是不能重写,不能继承
5. 如果类里有final方法,子类不能重写final方法但是可以继承
6. final不能修饰构造器
7. final和static搭配使用时不会导致类的加载[^底层编译做了优化]
8. 包装类和string是final类

# 抽象类(abstract)
当类的某些方法需要声明,但不知道如何实现时可以将其声明为抽象方法,那这个类就是抽象类
1. 没有方法体
2. 不能实例化
3. 抽象类可以没有抽象方法,可以实现方法
4. abstract只能修饰类和方法
5. 抽象类可以有正常的成员
6. 抽象方法不能有方法体
7. 抽象类的子类必须实现他的
19. 所有抽象方法,除非他自己也是抽象类
20. ![[Pasted image 20230728130936.png]]

# 接口
1. 接口就是给出没有实现的方法,封装到一起,到某个类要使用的时候再实现具体的方法
2. jdk8.0后可以有静态方法,和默认方法[^用def修饰 ]
## 注意事项
1. 不能实例化
2. 接口中的所有方法都是public方法,抽象方法可以省略修饰符
3. 普通类实现接口必须将该接口的所有方法实现
4. 抽象类实现接口可以不用实现接口的方法 
5. 一个类可以同时实现多个接口
	+ 需要同时实现所有的方法 
6. 接口中的所有属性都必须是public static final修饰符,`int=8`实际为`public static final int=8`
7. 接口中属性的访问形式接口名.属性名
8. 接口可以继承多个其他接口,但不能继承类
	1. interface a extends b,c{}
9. 接口的修饰符只能是public和默认
## 接口的多态
### 多态传递
1. 如果a接口继承了b接口而c类实现了a接口那么实际上就相当于c类也实现了b接口

# 内部类
分类
1. 定义在外部局部类位置上(比如方法,代码块内)
	1. 局部内部类(有类名)相当于一个局部变量
		1. 可以直接访问外部类的所有成员,包括私有的
		2. 不能添加访问修饰符,但是可以用final修饰.
		3. 可以被继承
		4. 作用域:仅仅在定义他的方法和代码块内
		5. 局部内部类可以直接访问外部类的成员
		6. 外部类访问内部类需要创建实例,然后调用
		7. 外部其他类不能访问局部内部类
		8. 外部类成员和局部内部类成员重名时,遵循就近原则,如果想访问外部类的成员,则可以使用(外部类吗.this.成员) ^248abb
	2. 匿名内部类(没有类名)
	 	语法
		   ![[Pasted image 20230729081045.png]]
		1. 需求:有些类只使用一次,传统方法需要专门写一个类,匿名内部类可以简化
		2. 内部类创建完实例后消失只能使用一次,他创建的实例可以继续使用
		1. 匿名内部类本身也是返回对象
		2. 匿名内部类的直接调用,可以传递参数![[Pasted image 20230729085439.png]]
		3. 可以访问外部类的所有成员,包括私有的
		4. 不能添加访问修饰符
		5. 作用域:定义他的方法和代码块中
		6. 外部其他类不能访问匿名内部类
		7. 外部类和匿名内部类重名时,同[[java#^248abb|内部类]]
1. 定义在外部类的成员位置上
	1. 成员内部类(没用static)
		1. 定义在外部类的成员位置,没有static修饰
		2. 可以访问外部类的所有成员,包括私有的
		3. 可以添加任意修饰符,因为他就只是一个成员
		4. 作用域:和外部类的其他成员一样,为整个类体
		5. 成员内部类访问外部类成员,直接访问
		6. 外部类访问成员内部类,创建成员内部类的对象,然后使用
		7. 外部其他类访问成员内部类
			1. 创建外部类实例
			   外部类.内部类 引用名=外部类实例.new 内部类();
			2. 在外部类中编写一个返回内部类对象实例的方法
		8. 外部类和内部类成员重名时同[[java#^248abb|内部类]]
	1. 静态内部类(使用static)
		1. 可以访问**非静态的**所有成员,包括私有的
		2. 可以添加所有访问修饰符
		3. 作用域:整个类体
		4. 外部类访问静态内部类需要创建对象
		5. 外部其他类访问静态内部类
			1. 外部类.内部类 引用名=外部类.new 内部类()
			2. 在外部类中编写一个返回静态内部类对象实例的方法
		6. 外部类和内部类重名时,访问规则遵循就近原则.访问外部类成员使用(外部类.成员 )

# 枚举类
## 自定义枚举类
## 关键字枚举类
1. 使用关键字enum替代class
2. `public static final 类名 对象名 = new 类名()`直接使用`常量名()`替代
3. 如果有多个常量,使用,号间隔
4. 关键字实现枚举类常量要放在最前面
5. 